#!/usr/bin/env python

__doc__="""update_upstreams PORT FILE

update_upstreams updates a file with a list of nginx upstream server
declarations.

It parses netstat output to find the list of contiguous ports, starting at
a given port, that have services listening (e.g., a system with 6 Zope instances
would have listeners at 9080-9085).  It then checks the specified file to see if
it is current. If it is not current, it updates the file to match the current
server list.

Exit codes:
    0 - Success, no update
    1 - Error
    2 - Server list was updated
"""

import sys
import argparse
import subprocess
from multiprocessing import Pool

def check_endpoint(p):
    try:
        # ZEN-28153: check a potential upstream by cURLing it
        # cURL <7.32.0 does not support decimal values for -m or --max-time
        result = subprocess.check_output('curl -s http://127.0.0.1:%d -m 1'%p, shell=True)
        return p
    except Exception:
        print >>sys.stderr, "No upstream found at https://127.0.0.1:%d"%p
        return -1

parser = argparse.ArgumentParser("update_upstreams", usage=__doc__)
parser.add_argument("port", type=int, help="port to start at")
parser.add_argument("filename", help="file to update")
args = parser.parse_args()

try:
    stdout = subprocess.check_output("netstat -ant | grep LISTEN | awk {'print $4'}", shell=True)
except Exception:
    print >>sys.stderr, "Unable to run netstat"
    sys.exit(1)

ports = sorted(set(int(line.split(':')[-1]) for line in stdout.splitlines()))

result = []
for p in ports:
    if p < args.port:
        continue
    if p == args.port or (result and p-result[-1] == 1):
        result.append(p)
    else:
        break

upstream_portnums = []
# ZEN-28153: ports shown in the netstat cmd results will still show as open
# even after the number of Zope upstreams have been decreased.
# So cURL each endpoint to make sure it's an actual upstream.
# We do it in parallel to avoid high latency for many upstreams
curl_pool = Pool(processes=len(result))
upstream_portnums = filter(lambda x: x != -1, curl_pool.map(check_endpoint, result))
curl_pool.terminate()
curl_pool.close()

servers = ["server 127.0.0.1:%d;" % p for p in upstream_portnums]
existing = []

try:
    with open(args.filename, 'r') as f:
        existing = [s.strip() for s in f.readlines()]
except IOError as e:
    pass

if servers and existing != servers:
    with open(args.filename, 'w') as f:
        f.write('\n'.join(servers))
    sys.exit(2)
